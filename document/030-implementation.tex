\section{Implementation}

\subsection{libsvm}

\emph{libsvm} is a C library developed by \textcite{CC01a} under BSD-3 license which implements the
Support Vector Machine (SVM) algorithm. The library is the de facto standard for SVM implementations in
the machine learning community, being used by many other libraries and frameworks such as
Python's sklearn~\cite{ScikitlearnScikitlearn2023} or R's e1071~\cite{meyer[autE1071MiscFunctions2023}.

Out of the box, \emph{libsvm} supports using the built-in kernels: linear, polynomial,
radial basis function (RBF) and sigmoid. Additionally, it can use precomputed kernel matrices
by setting the kernel type to \texttt{PRECOMPUTED} and passing the kernel matrix as the
training data.

\subsubsection{Adding the kernels}

For our purposes, we want to extend the library by adding our own kernels. To do so, we
need to modify the library source by adding the corresponding kernel functions. The kernel
type is specified through an \texttt{enum}, so we can add our own kernels to it and extend the
switch statements in the code to handle them. The modification is thus quite straightforward.
% \cite{arquemartinezDissenyImplementacioEstudi2021}

\subsubsection{Controlling the number of iterations}

One metric which we wanted to measure was the number of iterations the SVM algorithm took
and have the possibility to stop it early. To do so, \emph{libsvm} only provides a
\texttt{tolerance} parameter for the stopping criterion. However, in \emph{sklearn}
they provide a \texttt{max\_iter} parameter which is the maximum number of iterations
and also report the number of iterations the algorithm took. This is accomplished by 
using a modified version of \emph{libsvm}. Since we are modifying the library as well,
we added the same functionality.

\subsection{Julia}

\emph{Julia} \cite{bezanson2017julia} is a high-level, high-performance dynamic programming language
which is designed from the ground up to be fast, expressive, and easy to write. Its aim is to provide
the ease of use of a scripting language such as Python while being as fast as a compiled language
such as C. In particular, \emph{BinaryBuilder.jl} \cite{JLLPackagesBinaryBuilder} allows reproducible
cross-platform compilation of 3rd party libraries for different platforms and architectures.
This is used throughout the Julia ecosystem to provide binary dependencies for packages,
for example, \emph{libsvm} is provided by the \emph{libsvm\_jll} package \cite{LibsvmJllJl2022}.
This makes it very easy to change the \emph{libsvm} library used by a package by simply changing
the dependency to our modified \emph{libsvm\_jll} package.

For this reasons, and the fact that there is a large and growing number of machine learning
packages in Julia, we decided to interface our modified \emph{libsvm} library with Julia.

\subsection{libsvm\_jll}

As mentioned before, the \emph{libsvm\_jll} package is a compiled version of the \emph{libsvm} C library
compiled through \emph{BinaryBuilder.jl}. This so-called \emph{Julia Link Library} (JLL) package
is not much different from a regular system library, except that its dependencies are dynamically
linked to other JLL packages.

For our implementation, we used the original recipe from \textcite{LibsvmJllJl2022} and modified it
to use our modified \emph{libsvm} source code.

\subsection{LIBSVM.jl}

The \emph{LIBSVM.jl} package \cite{LIBSVMJl2023} is a Julia wrapper for the \emph{libsvm} library which
provides a high-level interface to the library. It uses the artifacts generated by the \emph{libsvm\_jll}
package and provides the translation between Julia types and the C types used by the library.

\subsubsection{Adding the kernels}

The kernels can be added by extending the \texttt{Kernel} \texttt{enum} in Julia to reflect the
\texttt{enum} in the C library.
\begin{minted}{julia}
module kernel
@enum KERNEL Linear Polynomial RadialBasis Sigmoid Precomputed Asin AsinNorm Acos0 Acos1 Acos2
end
\end{minted}

\subsubsection{Adding the number of iterations}

The modification of the number of iterations is a little more involved and requires modifying the
\texttt{SVMModel} and \texttt{SVMParameter} types to store the number of iterations as well
as properly copying the values from the C pointer into Julia object.

\subsubsection{libsvm 3.31}

The version of \emph{libsvm} used by \emph{LIBSVM.jl} is 3.25. It has not been updated to the
newest version 3.31 probably because it breaks the API by adding the option of
probability density estimation. Again, we worked around this by modifying the library to properly
handle the new API (this change will be upstreamed to \emph{LIBSVM.jl}). % TODO: link to PR

\subsection{MLJ}

\emph{MLJ} \cite{blaomMLJJuliaPackage2020} is a machine learning framework for Julia which provides a common interface
for many machine learning packages. It is the equivalent of \emph{scikit-learn} in Python. It provides
an interface to \emph{LIBSVM} through the \emph{MLJLIBSVMInterface.jl} package. By modifiying the latter
package to include the \texttt{max\_iter} parameter, we can use it in \emph{MLJ}.

From this point, we can use all the functionality provided by \emph{MLJ} to train, evaluate,
tune and visualize our SVM models with flexibility and ease.

\Cref{fig:julia_libsvm_deps} shows the relationship between the packages and how the
libraries interface with each other.

\begin{figure}[H]
\begin{tikzpicture}[
    box/.style={draw, rectangle, minimum width=1cm, minimum height=1cm},
    C/.style={fill=lightgray},
    Julia/.style={fill=lime!70},
    JLL/.style={fill=orange!50},
    ]
    \node[box,C] (libsvm) at (0,0) {libsvm};
    \node[box,JLL,below=of libsvm] (libsvm_jll) {libsvm\_jll};
    \node[box,Julia,right=of libsvm_jll] (LIBSVM) {LIBSVM.jl};
    \node[box,Julia,right=of LIBSVM] (MLJLIBSVMInterface) {MLJLIBSVMInterface.jl};
    \node[box,Julia,below=of MLJLIBSVMInterface] (MLJ) {MLJ.jl};

    \draw[->] (libsvm) -- (libsvm_jll) node[midway, anchor=west,color=lime!60!black] {build\_tarballs.jl};
    \draw[->] (libsvm_jll) -- (LIBSVM);
    \draw[->] (LIBSVM) -- (MLJLIBSVMInterface);
    \draw[->] (MLJLIBSVMInterface) -- (MLJ);

    % Color Legend
    \matrix [draw,right] at ($(current bounding box.east)+(0.5,0)$) {
      \node [C,label=right:C] {}; \\
      \node [JLL,label=right:Julia Link Library] {}; \\
      \node [Julia,label=right:Julia] {}; \\
    };

\end{tikzpicture}
\caption{Dependency graph of Julia packages exposing the libsvm library API.}
\label{fig:julia_libsvm_deps}
\end{figure}
